"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Compiler_instances, _Compiler_instance, _Compiler_initial, _Compiler_compilation, _Compiler_compilationParams, _Compiler_builtinPlugins, _Compiler_moduleExecutionResultsMap, _Compiler_nonSkippableRegisters, _Compiler_registers, _Compiler_ruleSet, _Compiler_build, _Compiler_createCompilation, _Compiler_resetThisCompilation, _Compiler_newCompilationParams, _Compiler_getInstance, _Compiler_updateNonSkippableRegisters, _Compiler_decorateJsTaps, _Compiler_createHookRegisterTaps, _Compiler_createHookMapRegisterTaps;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Compiler = void 0;
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack/blob/4b4ca3bb53f36a5b8fc6bc1bd976ed7af161bd80/lib/Compiler.js
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack/blob/main/LICENSE
 */
const binding = __importStar(require("@rspack/binding"));
const liteTapable = __importStar(require("@rspack/lite-tapable"));
const ExecuteModulePlugin_1 = __importDefault(require("./ExecuteModulePlugin"));
const ConcurrentCompilationError_1 = __importDefault(require("./error/ConcurrentCompilationError"));
const Cache_1 = __importDefault(require("./lib/Cache"));
const CacheFacade_1 = __importDefault(require("./lib/CacheFacade"));
const RuntimeGlobals_1 = require("./RuntimeGlobals");
const builtin_plugin_1 = require("./builtin-plugin");
const Chunk_1 = require("./Chunk");
const Compilation_1 = require("./Compilation");
const ContextModuleFactory_1 = require("./ContextModuleFactory");
const FileSystem_1 = require("./FileSystem");
const Module_1 = require("./Module");
const NormalModuleFactory_1 = require("./NormalModuleFactory");
const ResolverFactory_1 = require("./ResolverFactory");
const RuleSetCompiler_1 = require("./RuleSetCompiler");
const Stats_1 = require("./Stats");
const Watching_1 = require("./Watching");
const config_1 = require("./config");
const index_1 = require("./index");
const util_1 = require("./util");
const base_1 = require("./builtin-plugin/base");
const defaults_1 = require("./config/defaults");
const HookWebpackError_1 = require("./lib/HookWebpackError");
const Logger_1 = require("./logging/Logger");
const assertNotNil_1 = require("./util/assertNotNil");
const bindingVersionCheck_1 = require("./util/bindingVersionCheck");
const createHash_1 = require("./util/createHash");
const identifier_1 = require("./util/identifier");
class Compiler {
    constructor(context, options) {
        _Compiler_instances.add(this);
        _Compiler_instance.set(this, void 0);
        _Compiler_initial.set(this, void 0);
        _Compiler_compilation.set(this, void 0);
        _Compiler_compilationParams.set(this, void 0);
        _Compiler_builtinPlugins.set(this, void 0);
        _Compiler_moduleExecutionResultsMap.set(this, void 0);
        _Compiler_nonSkippableRegisters.set(this, void 0);
        _Compiler_registers.set(this, void 0);
        _Compiler_ruleSet.set(this, void 0);
        __classPrivateFieldSet(this, _Compiler_initial, true, "f");
        __classPrivateFieldSet(this, _Compiler_builtinPlugins, [], "f");
        __classPrivateFieldSet(this, _Compiler_nonSkippableRegisters, [], "f");
        __classPrivateFieldSet(this, _Compiler_moduleExecutionResultsMap, new Map(), "f");
        __classPrivateFieldSet(this, _Compiler_ruleSet, new RuleSetCompiler_1.RuleSetCompiler(), "f");
        this.hooks = {
            initialize: new liteTapable.SyncHook([]),
            shouldEmit: new liteTapable.SyncBailHook(["compilation"]),
            done: new liteTapable.AsyncSeriesHook(["stats"]),
            afterDone: new liteTapable.SyncHook(["stats"]),
            beforeRun: new liteTapable.AsyncSeriesHook(["compiler"]),
            run: new liteTapable.AsyncSeriesHook(["compiler"]),
            emit: new liteTapable.AsyncSeriesHook(["compilation"]),
            assetEmitted: new liteTapable.AsyncSeriesHook(["file", "info"]),
            afterEmit: new liteTapable.AsyncSeriesHook(["compilation"]),
            thisCompilation: new liteTapable.SyncHook(["compilation", "params"]),
            compilation: new liteTapable.SyncHook([
                "compilation",
                "params"
            ]),
            invalid: new liteTapable.SyncHook(["filename", "changeTime"]),
            compile: new liteTapable.SyncHook(["params"]),
            infrastructureLog: new liteTapable.SyncBailHook([
                "origin",
                "type",
                "args"
            ]),
            failed: new liteTapable.SyncHook(["error"]),
            shutdown: new liteTapable.AsyncSeriesHook([]),
            normalModuleFactory: new liteTapable.SyncHook([
                "normalModuleFactory"
            ]),
            contextModuleFactory: new liteTapable.SyncHook([
                "contextModuleFactory"
            ]),
            watchRun: new liteTapable.AsyncSeriesHook(["compiler"]),
            watchClose: new liteTapable.SyncHook([]),
            environment: new liteTapable.SyncHook([]),
            afterEnvironment: new liteTapable.SyncHook([]),
            afterPlugins: new liteTapable.SyncHook(["compiler"]),
            afterResolvers: new liteTapable.SyncHook(["compiler"]),
            make: new liteTapable.AsyncParallelHook(["compilation"]),
            beforeCompile: new liteTapable.AsyncSeriesHook(["params"]),
            afterCompile: new liteTapable.AsyncSeriesHook(["compilation"]),
            finishMake: new liteTapable.AsyncSeriesHook(["compilation"]),
            entryOption: new liteTapable.SyncBailHook(["context", "entry"])
        };
        this.webpack = index_1.rspack;
        this.rspack = index_1.rspack;
        this.root = this;
        this.outputPath = "";
        this.inputFileSystem = null;
        this.intermediateFileSystem = null;
        this.outputFileSystem = null;
        this.watchFileSystem = null;
        this.records = {};
        this.options = options;
        this.resolverFactory = new ResolverFactory_1.ResolverFactory();
        this.context = context;
        this.cache = new Cache_1.default();
        this.compilerPath = "";
        this.running = false;
        this.idle = false;
        this.watchMode = false;
        new builtin_plugin_1.JsLoaderRspackPlugin(this).apply(this);
        new ExecuteModulePlugin_1.default().apply(this);
    }
    get recordsInputPath() {
        return (0, util_1.unsupported)("Compiler.recordsInputPath");
    }
    get recordsOutputPath() {
        return (0, util_1.unsupported)("Compiler.recordsOutputPath");
    }
    get managedPaths() {
        return (0, util_1.unsupported)("Compiler.managedPaths");
    }
    get immutablePaths() {
        return (0, util_1.unsupported)("Compiler.immutablePaths");
    }
    get _lastCompilation() {
        return __classPrivateFieldGet(this, _Compiler_compilation, "f");
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    get __internal__builtinPlugins() {
        return __classPrivateFieldGet(this, _Compiler_builtinPlugins, "f");
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    get __internal__ruleSet() {
        return __classPrivateFieldGet(this, _Compiler_ruleSet, "f");
    }
    /**
     * @param name - cache name
     * @returns the cache facade instance
     */
    getCache(name) {
        return new CacheFacade_1.default(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);
    }
    /**
     * @param name - name of the logger, or function called once to get the logger name
     * @returns a logger with that name
     */
    getInfrastructureLogger(name) {
        if (!name) {
            throw new TypeError("Compiler.getInfrastructureLogger(name) called without a name");
        }
        let normalizedName = name;
        return new Logger_1.Logger((type, args) => {
            if (typeof normalizedName === "function") {
                normalizedName = normalizedName();
                if (!normalizedName) {
                    throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                }
            }
            else {
                if (this.hooks.infrastructureLog.call(normalizedName, type, args) ===
                    undefined) {
                    if (this.infrastructureLogger !== undefined) {
                        this.infrastructureLogger(normalizedName, type, args);
                    }
                }
            }
        }, (childName) => {
            let normalizedChildName = childName;
            if (typeof normalizedName === "function") {
                if (typeof normalizedChildName === "function") {
                    return this.getInfrastructureLogger(() => {
                        if (typeof normalizedName === "function") {
                            normalizedName = normalizedName();
                            if (!normalizedName) {
                                throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                            }
                        }
                        if (typeof normalizedChildName === "function") {
                            normalizedChildName = normalizedChildName();
                            if (!normalizedChildName) {
                                throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                            }
                        }
                        return `${normalizedName}/${normalizedChildName}`;
                    });
                }
                return this.getInfrastructureLogger(() => {
                    if (typeof normalizedName === "function") {
                        normalizedName = normalizedName();
                        if (!normalizedName) {
                            throw new TypeError("Compiler.getInfrastructureLogger(name) called with a function not returning a name");
                        }
                    }
                    return `${normalizedName}/${normalizedChildName}`;
                });
            }
            if (typeof normalizedChildName === "function") {
                return this.getInfrastructureLogger(() => {
                    if (typeof normalizedChildName === "function") {
                        normalizedChildName = normalizedChildName();
                        if (!normalizedChildName) {
                            throw new TypeError("Logger.getChildLogger(name) called with a function not returning a name");
                        }
                    }
                    return `${normalizedName}/${normalizedChildName}`;
                });
            }
            return this.getInfrastructureLogger(`${normalizedName}/${normalizedChildName}`);
        });
    }
    /**
     * @param watchOptions - the watcher's options
     * @param handler - signals when the call finishes
     * @returns a compiler watcher
     */
    watch(watchOptions, handler) {
        if (this.running) {
            // cannot be resolved without assertion
            // copy from webpack
            // Type 'void' is not assignable to type 'Watching'.
            return handler(new ConcurrentCompilationError_1.default());
        }
        this.running = true;
        this.watchMode = true;
        this.watching = new Watching_1.Watching(this, watchOptions, handler);
        return this.watching;
    }
    /**
     * @param callback - signals when the call finishes
     */
    run(callback) {
        if (this.running) {
            return callback(new ConcurrentCompilationError_1.default());
        }
        const startTime = Date.now();
        this.running = true;
        const doRun = () => {
            const finalCallback = (err, stats) => {
                this.idle = true;
                this.cache.beginIdle();
                this.idle = true;
                this.running = false;
                if (err) {
                    this.hooks.failed.call(err);
                }
                if (callback) {
                    callback(err, stats);
                }
                this.hooks.afterDone.call(stats);
            };
            this.hooks.beforeRun.callAsync(this, err => {
                if (err) {
                    return finalCallback(err);
                }
                this.hooks.run.callAsync(this, err => {
                    if (err) {
                        return finalCallback(err);
                    }
                    this.compile(err => {
                        if (err) {
                            return finalCallback(err);
                        }
                        __classPrivateFieldGet(this, _Compiler_compilation, "f").startTime = startTime;
                        __classPrivateFieldGet(this, _Compiler_compilation, "f").endTime = Date.now();
                        const stats = new Stats_1.Stats(__classPrivateFieldGet(this, _Compiler_compilation, "f"));
                        this.hooks.done.callAsync(stats, err => {
                            if (err) {
                                return finalCallback(err);
                            }
                            return finalCallback(null, stats);
                        });
                    });
                });
            });
        };
        if (this.idle) {
            this.cache.endIdle(err => {
                if (err)
                    return callback(err);
                this.idle = false;
                doRun();
            });
        }
        else {
            doRun();
        }
    }
    runAsChild(callback) {
        const finalCallback = (err, entries, compilation) => {
            try {
                callback(err, entries, compilation);
            }
            catch (e) {
                const err = new Error(`compiler.runAsChild callback error: ${e}`);
                // err.details = e.stack;
                this.parentCompilation.errors.push(err);
                // TODO: remove once this works
                console.log(e);
            }
        };
        this.compile((err, compilation) => {
            if (err) {
                return finalCallback(err);
            }
            (0, assertNotNil_1.assertNotNill)(compilation);
            this.parentCompilation.children.push(compilation);
            for (const { name, source, info } of compilation.getAssets()) {
                // Do not emit asset if source is not available.
                // Webpack will emit it anyway.
                if (source) {
                    this.parentCompilation.emitAsset(name, source, info);
                }
            }
            const entries = [];
            for (const ep of compilation.entrypoints.values()) {
                entries.push(...ep.chunks);
            }
            return finalCallback(null, entries, compilation);
        });
    }
    purgeInputFileSystem() {
        this.inputFileSystem?.purge?.();
    }
    /**
     * @param compilation - the compilation
     * @param compilerName - the compiler's name
     * @param compilerIndex - the compiler's index
     * @param outputOptions - the output options
     * @param plugins - the plugins to apply
     * @returns a child compiler
     */
    createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {
        const options = {
            ...this.options,
            output: {
                ...this.options.output,
                ...outputOptions
            }
        };
        (0, defaults_1.applyRspackOptionsDefaults)(options);
        const childCompiler = new Compiler(this.context, options);
        childCompiler.name = compilerName;
        childCompiler.outputPath = this.outputPath;
        childCompiler.inputFileSystem = this.inputFileSystem;
        childCompiler.outputFileSystem = null;
        childCompiler.modifiedFiles = this.modifiedFiles;
        childCompiler.removedFiles = this.removedFiles;
        childCompiler.fileTimestamps = this.fileTimestamps;
        childCompiler.contextTimestamps = this.contextTimestamps;
        childCompiler.fsStartTime = this.fsStartTime;
        childCompiler.cache = this.cache;
        childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;
        const relativeCompilerName = (0, identifier_1.makePathsRelative)(this.context, compilerName, this.root);
        if (!this.records[relativeCompilerName]) {
            this.records[relativeCompilerName] = [];
        }
        if (this.records[relativeCompilerName][compilerIndex]) {
            childCompiler.records = this.records[relativeCompilerName][compilerIndex];
        }
        else {
            this.records[relativeCompilerName].push((childCompiler.records = {}));
        }
        childCompiler.parentCompilation = compilation;
        childCompiler.root = this.root;
        if (Array.isArray(plugins)) {
            for (const plugin of plugins) {
                if (plugin) {
                    plugin.apply(childCompiler);
                }
            }
        }
        __classPrivateFieldSet(childCompiler, _Compiler_builtinPlugins, [
            ...__classPrivateFieldGet(childCompiler, _Compiler_builtinPlugins, "f"),
            ...__classPrivateFieldGet(this, _Compiler_builtinPlugins, "f").filter(plugin => plugin.canInherentFromParent === true)
        ], "f");
        for (const hookName in this.hooks) {
            const name = hookName;
            if ((0, base_1.canInherentFromParent)(name)) {
                if (childCompiler.hooks[name]) {
                    childCompiler.hooks[name].taps = this.hooks[name].taps.slice();
                }
            }
        }
        compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);
        return childCompiler;
    }
    isChild() {
        const isRoot = this.root === this;
        return !isRoot;
    }
    compile(callback) {
        const startTime = Date.now();
        const params = __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_newCompilationParams).call(this);
        this.hooks.beforeCompile.callAsync(params, (err) => {
            if (err) {
                return callback(err);
            }
            this.hooks.compile.call(params);
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_resetThisCompilation).call(this);
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_build).call(this, err => {
                if (err) {
                    return callback(err);
                }
                __classPrivateFieldGet(this, _Compiler_compilation, "f").startTime = startTime;
                __classPrivateFieldGet(this, _Compiler_compilation, "f").endTime = Date.now();
                this.hooks.afterCompile.callAsync(__classPrivateFieldGet(this, _Compiler_compilation, "f"), err => {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, __classPrivateFieldGet(this, _Compiler_compilation, "f"));
                });
            });
        });
    }
    close(callback) {
        if (this.watching) {
            // When there is still an active watching, close this #initial
            this.watching.close(() => {
                this.close(callback);
            });
            return;
        }
        this.hooks.shutdown.callAsync(err => {
            if (err)
                return callback(err);
            this.cache.shutdown(callback);
        });
    }
    /**
     * Note: This is not a webpack public API, maybe removed in future.
     * @internal
     */
    __internal__rebuild(modifiedFiles, removedFiles, callback) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
            if (error) {
                return callback?.(error);
            }
            instance.rebuild(Array.from(modifiedFiles || []), Array.from(removedFiles || []), error => {
                if (error) {
                    return callback?.(error);
                }
                callback?.(null);
            });
        });
    }
    __internal__registerBuiltinPlugin(plugin) {
        __classPrivateFieldGet(this, _Compiler_builtinPlugins, "f").push(plugin);
    }
    __internal__getModuleExecutionResult(id) {
        return __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").get(id);
    }
}
exports.Compiler = Compiler;
_Compiler_instance = new WeakMap(), _Compiler_initial = new WeakMap(), _Compiler_compilation = new WeakMap(), _Compiler_compilationParams = new WeakMap(), _Compiler_builtinPlugins = new WeakMap(), _Compiler_moduleExecutionResultsMap = new WeakMap(), _Compiler_nonSkippableRegisters = new WeakMap(), _Compiler_registers = new WeakMap(), _Compiler_ruleSet = new WeakMap(), _Compiler_instances = new WeakSet(), _Compiler_build = function _Compiler_build(callback) {
    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (error, instance) => {
        if (error) {
            return callback?.(error);
        }
        if (!__classPrivateFieldGet(this, _Compiler_initial, "f")) {
            instance.rebuild(Array.from(this.modifiedFiles || []), Array.from(this.removedFiles || []), error => {
                if (error) {
                    return callback?.(error);
                }
                callback?.(null);
            });
            return;
        }
        __classPrivateFieldSet(this, _Compiler_initial, false, "f");
        instance.build(error => {
            if (error) {
                return callback?.(error);
            }
            callback?.(null);
        });
    });
}, _Compiler_createCompilation = function _Compiler_createCompilation(native) {
    const compilation = new Compilation_1.Compilation(this, native);
    compilation.name = this.name;
    __classPrivateFieldSet(this, _Compiler_compilation, compilation, "f");
    return compilation;
}, _Compiler_resetThisCompilation = function _Compiler_resetThisCompilation() {
    // reassign new compilation in thisCompilation
    __classPrivateFieldSet(this, _Compiler_compilation, undefined, "f");
    // ensure thisCompilation must call
    this.hooks.thisCompilation.intercept({
        call: () => { }
    });
}, _Compiler_newCompilationParams = function _Compiler_newCompilationParams() {
    const normalModuleFactory = new NormalModuleFactory_1.NormalModuleFactory();
    this.hooks.normalModuleFactory.call(normalModuleFactory);
    const contextModuleFactory = new ContextModuleFactory_1.ContextModuleFactory();
    this.hooks.contextModuleFactory.call(contextModuleFactory);
    const params = {
        normalModuleFactory,
        contextModuleFactory
    };
    __classPrivateFieldSet(this, _Compiler_compilationParams, params, "f");
    return params;
}, _Compiler_getInstance = function _Compiler_getInstance(callback) {
    const error = (0, bindingVersionCheck_1.checkVersion)();
    if (error) {
        return callback(error);
    }
    if (__classPrivateFieldGet(this, _Compiler_instance, "f")) {
        return callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
    }
    const options = this.options;
    const rawOptions = (0, config_1.getRawOptions)(options, this);
    rawOptions.__references = Object.fromEntries(__classPrivateFieldGet(this, _Compiler_ruleSet, "f").builtinReferences.entries());
    const instanceBinding = require("@rspack/binding");
    __classPrivateFieldSet(this, _Compiler_registers, {
        registerCompilerThisCompilationTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerThisCompilation, () => this.hooks.thisCompilation, queried => (native) => {
            if (__classPrivateFieldGet(this, _Compiler_compilation, "f") === undefined) {
                __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createCompilation).call(this, native);
            }
            queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f"), __classPrivateFieldGet(this, _Compiler_compilationParams, "f"));
        }),
        registerCompilerCompilationTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerCompilation, () => this.hooks.compilation, queried => () => queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f"), __classPrivateFieldGet(this, _Compiler_compilationParams, "f"))),
        registerCompilerMakeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerMake, () => this.hooks.make, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f"))),
        registerCompilerFinishMakeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerFinishMake, () => this.hooks.finishMake, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f"))),
        registerCompilerShouldEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerShouldEmit, () => this.hooks.shouldEmit, queried => () => queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f"))),
        registerCompilerEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerEmit, () => this.hooks.emit, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f"))),
        registerCompilerAfterEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerAfterEmit, () => this.hooks.afterEmit, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f"))),
        registerCompilerAssetEmittedTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilerAssetEmitted, () => this.hooks.assetEmitted, queried => async ({ filename, targetPath, outputPath }) => {
            return queried.promise(filename, {
                compilation: __classPrivateFieldGet(this, _Compiler_compilation, "f"),
                targetPath,
                outputPath,
                get source() {
                    return this.compilation.getAsset(filename)?.source;
                },
                get content() {
                    return this.source?.buffer();
                }
            });
        }),
        registerCompilationAdditionalTreeRuntimeRequirements: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind
            .CompilationAdditionalTreeRuntimeRequirements, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.additionalTreeRuntimeRequirements, queried => ({ chunk, runtimeRequirements }) => {
            const set = (0, RuntimeGlobals_1.__from_binding_runtime_globals)(runtimeRequirements);
            queried.call(Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compiler_compilation, "f")), set);
            return {
                runtimeRequirements: (0, RuntimeGlobals_1.__to_binding_runtime_globals)(set)
            };
        }),
        registerCompilationRuntimeModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationRuntimeModule, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.runtimeModule, queried => ({ module, chunk }) => {
            const originSource = module.source?.source;
            queried.call(module, Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compiler_compilation, "f")));
            const newSource = module.source?.source;
            if (newSource && newSource !== originSource) {
                return module;
            }
            return;
        }),
        registerCompilationBuildModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationBuildModule, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.buildModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m, __classPrivateFieldGet(this, _Compiler_compilation, "f")))),
        registerCompilationStillValidModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationStillValidModule, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.stillValidModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m, __classPrivateFieldGet(this, _Compiler_compilation, "f")))),
        registerCompilationSucceedModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationSucceedModule, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.succeedModule, queired => (m) => queired.call(Module_1.Module.__from_binding(m, __classPrivateFieldGet(this, _Compiler_compilation, "f")))),
        registerCompilationExecuteModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationExecuteModule, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.executeModule, queried => ({ entry, id, codegenResults, runtimeModules }) => {
            const __webpack_require__ = (id) => {
                const cached = moduleCache[id];
                if (cached !== undefined) {
                    if (cached.error)
                        throw cached.error;
                    return cached.exports;
                }
                const execOptions = {
                    id,
                    module: {
                        id,
                        exports: {},
                        loaded: false,
                        error: undefined
                    },
                    require: __webpack_require__
                };
                for (const handler of interceptModuleExecution) {
                    handler(execOptions);
                }
                const result = codegenResults.map[id]["build time"];
                const moduleObject = execOptions.module;
                if (id)
                    moduleCache[id] = moduleObject;
                (0, HookWebpackError_1.tryRunOrWebpackError)(() => queried.call({
                    codeGenerationResult: new Module_1.CodeGenerationResult(result),
                    moduleObject
                }, { __webpack_require__ }), "Compilation.hooks.executeModule");
                moduleObject.loaded = true;
                return moduleObject.exports;
            };
            const moduleCache = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.moduleCache.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = {});
            const interceptModuleExecution = (__webpack_require__[RuntimeGlobals_1.RuntimeGlobals.interceptModuleExecution.replace(`${RuntimeGlobals_1.RuntimeGlobals.require}.`, "")] = []);
            for (const runtimeModule of runtimeModules) {
                __webpack_require__(runtimeModule);
            }
            const executeResult = __webpack_require__(entry);
            __classPrivateFieldGet(this, _Compiler_moduleExecutionResultsMap, "f").set(id, executeResult);
        }),
        registerCompilationFinishModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationFinishModules, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.finishModules, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f").modules)),
        registerCompilationOptimizeModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeModules, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.optimizeModules, queried => () => queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f").modules.values())),
        registerCompilationAfterOptimizeModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterOptimizeModules, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.afterOptimizeModules, queried => () => {
            queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f").modules.values());
        }),
        registerCompilationOptimizeTreeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeTree, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.optimizeTree, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f").chunks, __classPrivateFieldGet(this, _Compiler_compilation, "f").modules)),
        registerCompilationOptimizeChunkModulesTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationOptimizeChunkModules, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.optimizeChunkModules, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f").chunks, __classPrivateFieldGet(this, _Compiler_compilation, "f").modules)),
        registerCompilationChunkHashTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationChunkHash, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.chunkHash, queried => (chunk) => {
            if (!this.options.output.hashFunction) {
                throw new Error("'output.hashFunction' cannot be undefined");
            }
            const hash = (0, createHash_1.createHash)(this.options.output.hashFunction);
            queried.call(Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compiler_compilation, "f")), hash);
            const digestResult = hash.digest(this.options.output.hashDigest);
            return Buffer.from(digestResult);
        }),
        registerCompilationChunkAssetTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationChunkAsset, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.chunkAsset, queried => ({ chunk, filename }) => queried.call(Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compiler_compilation, "f")), filename)),
        registerCompilationProcessAssetsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationProcessAssets, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.processAssets, queried => async () => await queried.promise(__classPrivateFieldGet(this, _Compiler_compilation, "f").assets)),
        registerCompilationAfterProcessAssetsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterProcessAssets, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.afterProcessAssets, queried => () => queried.call(__classPrivateFieldGet(this, _Compiler_compilation, "f").assets)),
        registerCompilationSealTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationSeal, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.seal, queried => () => queried.call()),
        registerCompilationAfterSealTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.CompilationAfterSeal, () => __classPrivateFieldGet(this, _Compiler_compilation, "f").hooks.afterSeal, queried => async () => await queried.promise()),
        registerNormalModuleFactoryBeforeResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryBeforeResolve, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.beforeResolve, queried => async (resolveData) => {
            const normalizedResolveData = {
                contextInfo: {
                    issuer: resolveData.issuer
                },
                request: resolveData.request,
                context: resolveData.context,
                fileDependencies: [],
                missingDependencies: [],
                contextDependencies: []
            };
            const ret = await queried.promise(normalizedResolveData);
            resolveData.request = normalizedResolveData.request;
            resolveData.context = normalizedResolveData.context;
            return [ret, resolveData];
        }),
        registerNormalModuleFactoryFactorizeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryFactorize, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.factorize, queried => async (resolveData) => {
            const normalizedResolveData = {
                contextInfo: {
                    issuer: resolveData.issuer
                },
                request: resolveData.request,
                context: resolveData.context,
                fileDependencies: [],
                missingDependencies: [],
                contextDependencies: []
            };
            await queried.promise(normalizedResolveData);
            resolveData.request = normalizedResolveData.request;
            resolveData.context = normalizedResolveData.context;
            return resolveData;
        }),
        registerNormalModuleFactoryResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryResolve, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.resolve, queried => async (resolveData) => {
            const normalizedResolveData = {
                contextInfo: {
                    issuer: resolveData.issuer
                },
                request: resolveData.request,
                context: resolveData.context,
                fileDependencies: [],
                missingDependencies: [],
                contextDependencies: []
            };
            await queried.promise(normalizedResolveData);
            resolveData.request = normalizedResolveData.request;
            resolveData.context = normalizedResolveData.context;
            return resolveData;
        }),
        registerNormalModuleFactoryResolveForSchemeTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookMapRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryResolveForScheme, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.resolveForScheme, queried => async (args) => {
            const ret = await queried
                .for(args.scheme)
                .promise(args.resourceData);
            return [ret, args.resourceData];
        }),
        registerNormalModuleFactoryAfterResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryAfterResolve, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.afterResolve, queried => async (arg) => {
            const data = {
                contextInfo: {
                    issuer: arg.issuer
                },
                request: arg.request,
                context: arg.context,
                fileDependencies: arg.fileDependencies,
                missingDependencies: arg.missingDependencies,
                contextDependencies: arg.contextDependencies,
                createData: arg.createData
            };
            const ret = await queried.promise(data);
            return [ret, data.createData];
        }),
        registerNormalModuleFactoryCreateModuleTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.NormalModuleFactoryCreateModule, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").normalModuleFactory.hooks.createModule, queried => async (args) => {
            const data = {
                ...args,
                settings: {}
            };
            await queried.promise(data, {});
        }),
        registerContextModuleFactoryBeforeResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.ContextModuleFactoryBeforeResolve, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").contextModuleFactory.hooks.beforeResolve, queried => async (bindingData) => {
            return queried.promise(bindingData);
        }),
        registerContextModuleFactoryAfterResolveTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.ContextModuleFactoryAfterResolve, () => __classPrivateFieldGet(this, _Compiler_compilationParams, "f").contextModuleFactory.hooks.afterResolve, queried => async (bindingData) => {
            const data = bindingData
                ? ({
                    resource: bindingData.resource,
                    regExp: bindingData.regExp
                        ? new RegExp(bindingData.regExp.source, bindingData.regExp.flags)
                        : undefined,
                    request: bindingData.request,
                    context: bindingData.context,
                    // TODO: Dependencies are not fully supported yet; this is a placeholder to prevent errors in moment-locales-webpack-plugin.
                    dependencies: []
                })
                : false;
            const ret = await queried.promise(data);
            const result = ret
                ? ({
                    resource: ret.resource,
                    context: ret.context,
                    request: ret.request,
                    regExp: ret.regExp
                        ? {
                            source: ret.regExp.source,
                            flags: ret.regExp.flags
                        }
                        : undefined
                })
                : false;
            return result;
        }),
        registerJavascriptModulesChunkHashTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.JavascriptModulesChunkHash, () => builtin_plugin_1.JavascriptModulesPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f"))
            .chunkHash, queried => (chunk) => {
            if (!this.options.output.hashFunction) {
                throw new Error("'output.hashFunction' cannot be undefined");
            }
            const hash = (0, createHash_1.createHash)(this.options.output.hashFunction);
            queried.call(Chunk_1.Chunk.__from_binding(chunk, __classPrivateFieldGet(this, _Compiler_compilation, "f")), hash);
            const digestResult = hash.digest(this.options.output.hashDigest);
            return Buffer.from(digestResult);
        }),
        registerHtmlPluginBeforeAssetTagGenerationTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginBeforeAssetTagGeneration, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f"))
            .beforeAssetTagGeneration, queried => async (data) => {
            return await queried.promise({
                ...data,
                plugin: {
                    options: builtin_plugin_1.HtmlRspackPlugin.getCompilationOptions(__classPrivateFieldGet(this, _Compiler_compilation, "f")) ||
                        {}
                }
            });
        }),
        registerHtmlPluginAlterAssetTagsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginAlterAssetTags, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f"))
            .alterAssetTags, queried => async (data) => {
            return await queried.promise(data);
        }),
        registerHtmlPluginAlterAssetTagGroupsTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginAlterAssetTagGroups, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f"))
            .alterAssetTagGroups, queried => async (data) => {
            return await queried.promise({
                ...data,
                plugin: {
                    options: builtin_plugin_1.HtmlRspackPlugin.getCompilationOptions(__classPrivateFieldGet(this, _Compiler_compilation, "f")) || {}
                }
            });
        }),
        registerHtmlPluginAfterTemplateExecutionTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginAfterTemplateExecution, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f"))
            .afterTemplateExecution, queried => async (data) => {
            return await queried.promise({
                ...data,
                plugin: {
                    options: builtin_plugin_1.HtmlRspackPlugin.getCompilationOptions(__classPrivateFieldGet(this, _Compiler_compilation, "f")) ||
                        {}
                }
            });
        }),
        registerHtmlPluginBeforeEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginBeforeEmit, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f")).beforeEmit, queried => async (data) => {
            return await queried.promise({
                ...data,
                plugin: {
                    options: builtin_plugin_1.HtmlRspackPlugin.getCompilationOptions(__classPrivateFieldGet(this, _Compiler_compilation, "f")) || {}
                }
            });
        }),
        registerHtmlPluginAfterEmitTaps: __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_createHookRegisterTaps).call(this, binding.RegisterJsTapKind.HtmlPluginAfterEmit, () => builtin_plugin_1.HtmlRspackPlugin.getCompilationHooks(__classPrivateFieldGet(this, _Compiler_compilation, "f")).afterEmit, queried => async (data) => {
            return await queried.promise({
                ...data,
                plugin: {
                    options: builtin_plugin_1.HtmlRspackPlugin.getCompilationOptions(__classPrivateFieldGet(this, _Compiler_compilation, "f")) || {}
                }
            });
        })
    }, "f");
    __classPrivateFieldSet(this, _Compiler_instance, new instanceBinding.Rspack(rawOptions, __classPrivateFieldGet(this, _Compiler_builtinPlugins, "f"), __classPrivateFieldGet(this, _Compiler_registers, "f"), FileSystem_1.ThreadsafeWritableNodeFS.__to_binding(this.outputFileSystem), ResolverFactory_1.ResolverFactory.__to_binding(this.resolverFactory)), "f");
    callback(null, __classPrivateFieldGet(this, _Compiler_instance, "f"));
}, _Compiler_updateNonSkippableRegisters = function _Compiler_updateNonSkippableRegisters() {
    const kinds = [];
    for (const { getHook, getHookMap, registerKind } of Object.values(__classPrivateFieldGet(this, _Compiler_registers, "f"))) {
        const get = getHook ?? getHookMap;
        const hookOrMap = get();
        if (hookOrMap.isUsed()) {
            kinds.push(registerKind);
        }
    }
    if (__classPrivateFieldGet(this, _Compiler_nonSkippableRegisters, "f").join() !== kinds.join()) {
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_getInstance).call(this, (_error, instance) => {
            instance.setNonSkippableRegisters(kinds);
            __classPrivateFieldSet(this, _Compiler_nonSkippableRegisters, kinds, "f");
        });
    }
}, _Compiler_decorateJsTaps = function _Compiler_decorateJsTaps(jsTaps) {
    if (jsTaps.length > 0) {
        const last = jsTaps[jsTaps.length - 1];
        const old = last.function;
        last.function = (...args) => {
            const result = old(...args);
            if (result && typeof result.then === "function") {
                return result.then((r) => {
                    __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateNonSkippableRegisters).call(this);
                    return r;
                });
            }
            __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_updateNonSkippableRegisters).call(this);
            return result;
        };
    }
}, _Compiler_createHookRegisterTaps = function _Compiler_createHookRegisterTaps(registerKind, getHook, createTap) {
    const getTaps = (stages) => {
        const hook = getHook();
        if (!hook.isUsed())
            return [];
        const breakpoints = [
            liteTapable.minStage,
            ...stages,
            liteTapable.maxStage
        ];
        const jsTaps = [];
        for (let i = 0; i < breakpoints.length - 1; i++) {
            const from = breakpoints[i];
            const to = breakpoints[i + 1];
            const stageRange = [from, to];
            const queried = hook.queryStageRange(stageRange);
            if (!queried.isUsed())
                continue;
            jsTaps.push({
                function: createTap(queried),
                stage: liteTapable.safeStage(from + 1)
            });
        }
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_decorateJsTaps).call(this, jsTaps);
        return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHook = getHook;
    return getTaps;
}, _Compiler_createHookMapRegisterTaps = function _Compiler_createHookMapRegisterTaps(registerKind, getHookMap, createTap) {
    const getTaps = (stages) => {
        const map = getHookMap();
        if (!map.isUsed())
            return [];
        const breakpoints = [
            liteTapable.minStage,
            ...stages,
            liteTapable.maxStage
        ];
        const jsTaps = [];
        for (let i = 0; i < breakpoints.length - 1; i++) {
            const from = breakpoints[i];
            const to = breakpoints[i + 1];
            const stageRange = [from, to];
            const queried = map.queryStageRange(stageRange);
            if (!queried.isUsed())
                continue;
            jsTaps.push({
                function: createTap(queried),
                stage: liteTapable.safeStage(from + 1)
            });
        }
        __classPrivateFieldGet(this, _Compiler_instances, "m", _Compiler_decorateJsTaps).call(this, jsTaps);
        return jsTaps;
    };
    getTaps.registerKind = registerKind;
    getTaps.getHookMap = getHookMap;
    return getTaps;
};
